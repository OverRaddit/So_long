# 전체적인 구현





# 개인적인 고찰 - 왜 재할당시 용량을 2배 할당하기로 했는가?

재할당 시 기존 배열 용량의 2배를 새로 할당한다. 왜 2배인가?

여기서부터의 설명은 종만북 선형 자료구조에 나온 설명이다.

재할당 코드 조각에서 우리는 배열의 용량을 한번에 M씩 늘렸습니다.
그러면 M번의 append() 연산 후에느 재할당이 일어나게 됩니다.

예를들어 M = 100으로 두면, 재할당 때마다 100개 여유분을 할당받습니다.

그럼 처음 만든 텅 빈 배열의 용량은 100이겠죠.

여기에서 시작해서 append()연산을 1만번 수행한다고 합시다.

이때 재할당은 총 99번 일어납니다.(10000 / 100 - 1(처음할당받은크기제외))

(배열의 크기가 100을 넘어갈 때, 200을 넘어갈 때,,,,9900을 넘어갈 때)

각각의 경우 복사해야ㅐ 하는 원소의 수는 현재 배열의 크기와 같으므로, 복사의 전체 수는

100 + 200 + 300 + ... + 9900 = 495,000 입니다.

크기가 1만인 배열을 만드는 데 50만 번의 복사가 필요하다니, 이쯤 되면 범죄죠!

그럼 M을 더 늘리면 어떨까요? M=1000으로 두면 1만 번 append()연산을 할때

재할당을 아홉번만 해도 됩니다. 복사의 수 또한

1000 + 2000 + ... + 9000 = 45,000으로 크게 줄어들지요.

하지만 이래서는 크기가 3인 정수 배열을 저장하는 데도 1000개를 위한 공간을 할당받아야 하므로, 낭비가 심각합니다.

좀 더 자세히 분석해보면 M을 늘리는 것은 아무런 의미가 없음을 깨달을 수 있습니다.

# 텅빈 배열로 시작해서 N번 append연산을 할 때 재할당의 수는

K = O(N/M)입니다.

M은 상수니까 N이 아주 커지면 결국 K = O(N)이라고도 쓸 수 있지요.

이때 재할당마다 복사하는 원소의 수는 M, 2M, ..., KM개로 증가하므로

전체 복사하는 원소의 수는 다음과 같다.

K(K+1)/2 x M = O(K^2) = O(N^2)

N번의 append 연산을 하는 데 ㄷ는 총 시간이 O(N^2)이라면

한번의 연산에 드는 시간은 평균적으로 O(N)이 됩니다.
